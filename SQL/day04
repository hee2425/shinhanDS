select * from user_constraints
where table_name = 'TBL_ORDER';

drop table tbl_test1;
create table tbl_test1(id number CONSTRAINT pk_tbl_test1_id primary key, name varchar(20) not null,
                        phone_number varchar2(13)CONSTRAINT u_phone unique);
insert into tbl_test1(id, name) values(1,'aa');
insert into tbl_test1(id, name, phone_number) values(3,'aa','010-4567-7896');

select * from user_cons_columns where table_name = 'TBL_ORDER';

--주문(고객, 상품, 일자, 가격)
create table tbl_order( 고객 number, 상품 number, order_date date, price number, 
    CONSTRAINT pk_order PRIMARY KEY(고객, 상품)
);

--primary key = not null + unique
insert into tbl_order values(1, 100, sysdate, 1000);



select * from departments;
select * from employees;
select * from user_constraints where table_name = 'DEPARTMENTS';
select * from user_constraints where table_name = 'EMPLOYEES';
select * from user_cons_columns where table_name = 'EMPLOYEES';

--parent key not found
update employees
set department_id = 1;

ALTER TRIGGER UPDATE_JOB_HISTORY disable;

drop table tbl_parent;  --다른 테이블에서 fk로 지정되어있기 때문에 지워질 수 없음
create table tbl_parent(deptid number primary key, deptname varchar2(20));

drop table tbl_child;
create table tbl_child(empid number primary key, empname varchar2(20), deptid number CONSTRAINT tbl_parent_deptid_FK references tbl_parent(deptid));

create table tbl_child(empid number primary key, empname varchar2(20) not null, 
    deptid number CONSTRAINT tbl_parent_deptid_FK references tbl_parent(deptid),
    salary number constraint tbl_child_salary_check check(salary between 1000 and 2000), 
    gender char(1) constraint tbl_child_gender_check check(gender in('M', 'F')),
    phone_number char(13) unique,
    국적 varchar2(30) default '한국'
    );

insert into tbl_parent(deptid, deptname) values(10,'개발부');
insert into tbl_parent(deptid, deptname) values(20,'영업부');
insert into tbl_parent(deptid, deptname) values(30,'총무부');

--parent key not found
insert into tbl_child(empid, empname, deptid) values(2, 'aa', 100);
insert into tbl_child values(2, 'bb', 20);
insert into tbl_child(empid, deptid, empname) values(3,30,'cc');
insert into tbl_child(empid, empname) values(4,'cc');


insert into tbl_child(empid, empname, deptid, salary, gender, phone_number) values(1, 'aa',10,  null, null, null);
insert into tbl_child values(2, 'bb', 10, 500, null, null);  --check constraint (HR.TBL_CHILD_SALARY_CHECK) violated
insert into tbl_child values(2, 'bb', 10, 1500, null, null); 
insert into tbl_child values(3, 'cc', 10, 1500, 'M', '12345'); 


select * from tbl_child;

--subquery를 이용해서 table생성, not null만 복사
create table tbl_emp_backup
as
select * from employees
where department_id = 60;

select * from tbl_emp_backup;

select * from user_constraints where table_name = 'TBL_EMP_BACKUP';

update tbl_emp_backup
set department_id=100;
rollback;

--제약조건 추가
alter table tbl_emp_backup
add constraints tbl_emp_backup_PK primary key(employee_id);

alter table tbl_emp_backup
add constraint tbl_emp_backup_FK
foreign key(department_id) references departments(department_id);

--=========VIEW=======================
desc employees;

create or replace view empView1
as
select employee_id, first_name, last_name, email, hire_date, job_id, department_id
from employees
where department_id = 60 with check option;

select * from user_views;
desc empView1;

select * from empView1;

--뷰안의 부서코드를 모두 100으로 바꿔라
update empView1
set department_id = 100;  --WITH CHECK OPTION
rollback;

select empView1.*, jobs.job_title
from empView1 join jobs on(empView1.job_id = jobs.job_id);


update empView1
set email = 'zzahee@gmail.com'
where employee_id = 103;
commit;

select * from employees where employee_id = 103;


--테이블을 여러개 조인해서 만들면 수정할수 없다 --조회목적
--force : 무조건 생성, noforce(default) : 체크해서 문제없으면 생성
create or replace force view view_join4
as
select first_name, department_name,city, country_name
from employees2 join departments using(department_id)
                join locations using(location_id)
                join countries using(country_id);
                
select *from view_join4;


--시퀀스 연습------
create sequence seq_board;
create table tbl_board(bno number primary key, 
                        title varchar2(50) not null, 
                        contents varchar2(2000), 
                        writer varchar2(30) not null);
                        
                        
insert into tbl_board(bno, title, contents, writer) values(seq_board.nextval,'수요일','sql배우기','pp');   
select * from tbl_board;
select 2000/3 from dual;



select * 
from user_ind_columns
where table_name = 'EMPLOYEES';

--실행계획(f10)

--인덱스가 만들어져있는데 굳이 full스캔, 좋지 않음
select * 
from employees
where lower(first_name) = 'steven' and lower(last_name) = 'king';

--테이블 값을 바꾸는 것보다 내가 주어지는 것을 바꾸는 것이 훨씬 더 좋은 쿼리
select * 
from employees
where first_name = initCap('steven') and last_name = initCap('king');

insert into tbl_board(bno, title, contents, writer) values(seq_board.nextval,'목요일','sql배우기','pp');   
select * from tbl_board where title ='수요일';


--인덱스 생성  --range scan 인덱스 사용
create index idx_tbl_board_title
on tbl_board(title);



show recyclebin;       --휴지통에 있는 테이블을 조회
flashback table 테이블명 to before drop;       -- 삭제된 테이블을 복원
drop table 테이블명 purge;     -- 휴지통에 남기지 않고 완전 삭제
purge table 테이블명;      -- 휴지통에 있는 테이블 완전 삭제
purge recyclebin;      -- 휴지통 비우기


select * from employees;
insert into employees values(207, 'Hee', 
